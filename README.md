## 람다, 스트림, 함수형 프로그래밍

### 람다
**람다란?**
- 자바 8에서 도입된 익명 함수로, 이름 없이 간결하게 함수를 표현한다.
- 예: (x) -> x + 1
- 익명 클래스보다 보일러플레이트 코드를 줄여 생산성과 가독성을 높이는 문법 설탕 역할.

**함수형 인터페이스**
- 람다를 사용할 수 있는 기반으로, 단일 추상 메서드(SAM)만 포함하는 인터페이스.
- 예: @FunctionalInterface 로 보장하며, 하나의 메서드만 정의.
- 여러 메서드가 있으면 람다 할당 불가(모호성 방지).

**람다 문법**
- 기본 형태: (매개변수) -> {본문}
- 생략 가능
  - 단일 표현식(본문, 반환 생략): x -> x + 1
  - 타입 추론: (int x) -> x x -> x
  - 매개변수 괄호(단일 매개변수일 때): x -> x
- 시그니처(매개변수 수/타입, 반환 타입)이 함수형 인터페이스와 일치해야 함.

**람다 활용**
- 변수 대입: MyFunction f = (a, b) -> a + b; 처럼 람다 인스턴스를 변수에 저장.
- 메서드 전달: calculate((a, b) -> a + b) 로 함수처럼 전달 가능.
- 반환: return (a, b) --> a + b; 로 메서드에서 람다를 반환.

**고차 함수**
- 함수를 인자나 반환값으로 다루는 함수(예: filter , map , reduce ).
- 자바에서는 함수형 인터페이스와 람다로 구현하며, 코드의 유연성과 추상화 수준을 높임.
- 예: List<Integer> filter(List<Integer> list, MyPredicate p) 는 조건 함수를 받아 동작.

**기타**
- 람다는 익명 클래스를 간소화한 도구지만, 내부적으로 인스턴스가 생성됨.


### 함수형 인터페이스
**함수형 인터페이스와 제네릭**
- 함수형 인터페이스에 제네릭을 도입하면 코드 재사용성과 타입 안전성을 모두 확보할 수 있다.
- 직접 Object 타입을 사용하는 방식( ObjectFunction )은 다양한 타입을 다룰 수 있지만, 다운캐스팅 과정이 필요하고 타입 안정성이 떨어진다.
- 제네릭 타입을 사용하면 컴파일 시점에 타입 체크가 이루어지므로, 런타임 에러를 방지할 수 있고 유연한 코드를 작성할 수 있다.

**람다와 타겟 타입**
- 람다는 그 자체로 타입이 정해져 있지 않고, 어떤 함수형 인터페이스에 대입되느냐(타겟 타입)에 따라 타입이 결정된다.
- 같은 람다라도 FunctionA 에 대입하면 FunctionA 타입이 되고, FunctionB 에 대입하면 FunctionB 타입이 된다.
- 이미 한 번 특정 함수형 인터페이스 타입으로 대입된 람다는, 시그니처가 같더라도 다른 함수형 인터페이스 타입으로 대입할 수 없다.

**자바가 제공하는 기본 함수형 인터페이스**
- Function<T, R> : 하나의 매개변수를 받아 결과를 반환한다.
- Consumer<T> : 하나의 매개변수를 받아서 소비(처리)만 하고, 반환값은 없다.
- Supplier<T> : 매개변수가 없고, 값을 공급(생성)하여 반환한다.
- Runnable : 매개변수와 반환값이 모두 없는 실행 작업을 나타낸다(주로 스레드 실행).
 
**특화 함수형 인터페이스**
- Predicate<T> : 입력값을 받아 조건을 검사(필터링)하고 boolean 을 반환한다.
- UnaryOperator<T> : 하나의 같은 타입 입력을 받아 같은 타입을 반환(단항 연산)한다.
- BinaryOperator<T> : 두 개의 같은 타입 입력을 받아 같은 타입을 반환(이항 연산)한다.
- 이외에도 매개변수가 2개 이상인 경우 BiFunction<T, U, R> , BiConsumer<T, U>, BiPredicate<T, U> 등이 있으며, 기본형(primitive) 전용 함수형 인터페이스(IntFunction, IntPredicate 등)도 별도로 제공한다.

**문제 예시와 풀이**
- filter , map , reduce 예제를 통해 직접 만든 함수형 인터페이스를 자바가 제공하는 Predicate, UnaryOperator , BinaryOperator 등으로 대체하는 과정을 살펴보았다.
- 일반적으로 입력과 반환의 구조와 의도를 가장 명확히 드러내는 함수형 인터페이스를 선택하면 된다.
- 예: 조건 검사 시 Predicate , 단항 연산 시 UnaryOperator , 이항 연산 시 BinaryOperator 등.

정리하자면, 람다와 함수형 인터페이스를 제대로 활용하면 코드가 간결해지고 가독성이 높아지며, 제네릭을 도입하면
재사용성과 타입 안전성까지 모두 확보할 수 있다. 또한 자바가 기본적으로 제공하는 다양한 함수형 인터페이스를 적극
활용하면, 불필요하게 유사한 인터페이스를 여러 개 만들 필요가 없고 호환성 문제도 해결된다. 


### 람다 활용
**명령형(Imperative) vs 선언형(Declarative) 프로그래밍**
- 명령형 프로그래밍은 어떻게(How) 문제를 해결할지 로직 단계별로 명령(지시)을 상세히 기술한다. 주로 for , if 와 같은 제어문을 사용하며, 로직이 복잡해질수록 중복 코드가 늘어날 수 있다.
- 선언형 프로그래밍은 무엇(What)을 해야 하는지에 집중한다. 예를 들어 "짝수만 필터하고, 그 값을 2배로 변환"처럼 원하는 결과만 기술하면, 내부의 세부 로직(어떻게 필터링하고 변환하는지)은 외부에서 신경 쓰 지 않는다. 이는 코드 가독성과 유지보수성을 높일 수 있다.

**Filter와 Map**
- 조건에 맞는 값만 선별하는 작업을 필터라고 하고, 값을 다른 값으로 변환하는 과정을 매핑(Map)이라고 한다.
- 자바에서 제공하는 Predicate , Function 같은 표준 함수형 인터페이스를 사용하여 람다 형식으로 필터와 맵을 자유롭게 조합할 수 있다.
- 필터와 맵을 유틸리티 메서드(GenericFilter, GenericMapper)로 분리해두면 다양한 타입(T)에 대해 재사용할 수 있어 코드 중복을 줄이고 선언형 프로그래밍 스타일을 쉽게 적용할 수 있다.
  
**Stream (스트림)**
- 필터와 맵을 포함한 여러 연산을 연속해서 적용하기 위해, 이를 하나의 흐름(스트림)으로 표현한 것이다.
- 스트림을 사용하면 메서드 체인 방식으로 filter() , map() , forEach() 등을 연결해 호출할 수 있으므로, 중간 변수를 만들 필요 없이 깔끔하게 데이터를 가공할 수 있다.
- 내부 반복(Internal Iteration)을 지원해, 개발자가 명시적으로 for 루프를 작성하지 않고도 반복 처리 로직을 스트림 내부에 위임할 수 있다. 이로써 간결하고 직관적인 코드 작성이 가능하다.

**내부 반복 vs 외부 반복**
- 외부 반복: 기존의 for , while 루프처럼, 개발자가 반복 제어를 직접 담당하며 명령형 스타일이다. 중간에 break , continue 등이 들어가는 로직을 구현하기 쉽다.
- 내부 반복: 스트림의 forEach 처럼, 반복 제어를 스트림에 맡기고 개발자는 "어떤 작업을 할지(Consumer)"만 정의하면 된다. 이는 선언형 프로그래밍 스타일로써 코드가 짧고 의도가 명확하다.

**정적 팩토리 메서드 (static factory method)**
- 객체 생성 과정을 메서드로 캡슐화하여 가독성을 높이는 기법이다. 예) MyStreamV3.of(list).
- 생성자에 이름을 붙이지 못하는 한계를 보완하며, 객체 캐싱 또는 하위 타입 객체 반환 같은 유연한 로직을 적용할 수 있다.


### 람다 vs 익명 클래스
**문법 및 가독성**
- 익명 클래스는 새로운 클래스를 정의하고 바로 인스턴스를 생성한다. 문법적으로 다소 복잡하고 장황하며,여러 메서드를 동시에 오버라이드할 수도 있다.
- 람다는 단일 메서드만을 가지는 함수형 인터페이스를 구현할 때 사용되며, 문법이 간결하여 읽기 쉽다.

**this 키워드 해석**
- 익명 클래스 내부의 this 는 익명 클래스 자체의 인스턴스를 가리킨다.
- 람다 내부의 this 는 람다가 선언된 외부 클래스의 인스턴스를 가리킨다.

**상속 및 상태 관리**
- 익명 클래스는 클래스를 상속하거나 여러 메서드를 가진 인터페이스를 구현할 수 있고, 내부에 상태(필드)를 가질 수 있다.
- 람다는 오직 함수형 인터페이스만 구현 가능하며, 내부 상태(필드)를 유지하기 어렵다(함수로서 동작).

**호환성과 내부 동작**
- 익명 클래스는 자바의 오래된 버전(람다 이전 버전)에서도 사용 가능하며, 컴파일 시 실제 익명 클래스(OuterClass$1.class 등)가 생성된다.
- 람다는 자바 8 이상에서 사용 가능하며, 내부적으로 invokeDynamic 을 활용하여 별도의 클래스 파일이 아닌, 런타임 시점에 동적으로 람다 인스턴스를 생성한다.

**캡처링(capturing) 규칙**
- 둘 다 외부 로컬 변수를 참조할 때, final 또는 "사실상 final"인 지역 변수만 참조할 수 있다.
- 값이 변경되는 지역 변수는 캡처할 수 없다.

**언제 어떤 것을 사용할까?**
- 복잡한 인터페이스 구현(메서드가 여러 개)이 필요하거나, 상태를 유지해야 하는 경우는 익명 클래스를 사용한다.
- 간결성과 함수형 방식이 필요한 경우(함수형 인터페이스 하나만 구현)에는 람다가 훨씬 직관적이며, 코드량을 줄일 수 있다.


### 메서드 참조
**메서드 참조의 필요성**
- 람다에서 이미 정의된 메서드를 단순히 호출하기만 하는 경우, 메서드 참조로 더 간결하게 표현할 수 있다.
- 코드 중복을 줄이고 가독성을 높여주며, 유지보수 측면에서도 편리하다.

1.간결성
   - 람다 표현식을 더욱 간단하게 표현할 수 있다.
   - 매개변수를 생략한다.
   - 특히 메서드 체이닝에서 코드가 매우 깔끔해진다.
2. 가독성
   - 메서드 이름을 직접 사용하여 의도가 더 명확해진다.
   - 복잡한 람다 표현식을 단순화할 수 있다.
3. 유연성
   - 다양한 함수형 인터페이스와 함께 사용할 수 있다.
   - 스트림 API와 결합하여 강력한 데이터 처리 가능하다. ( MyStream 을 떠올려보자.)
4. 재사용성
   - 기존 메서드를 람다 표현식으로 쉽게 변환할 수 있다.
   - 동일한 메서드를 여러 컨텍스트에서 재사용할 수 있다.

**메서드 참조의 4가지 유형**
- 정적 메서드 참조: 클래스명::메서드명
- 특정 객체의 인스턴스 메서드 참조: 객체명::메서드명
- 생성자 참조: 클래스명::new
- 임의 객체의 인스턴스 메서드 참조: 클래스명::메서드명
  - 클래스명으로 지정한 첫 번째 매개변수가 곧 호출 대상 객체가 된다.

**임의 객체의 인스턴스 메서드 참조**
- 특정 타입의 객체가 런타임에 주어지면, 그 객체를 사용해 인스턴스 메서드를 호출하는 방식을 간단하게 표현한다.
- 예: (Person p) -> p.introduce() 대신 Person::introduce 로 표기

**활용 예시**
- 컬렉션( List , Map 등)의 원소들을 변환( map )할 때, or 스트림( Stream )에서 map , filter 등을 사용할때, 이미 정의된 메서드를 그대로 쓸 수 있다면 메서드 참조를 사용해 더욱 깔끔하고 직관적인 코드를 작성할 수 있다.

**람다와의 관계**
- 메서드 참조는 람다를 메서드 호출만으로 축약한 문법이며, 내부 동작은 사실상 동일하다.
- 람다로 표현하기에 직관적인 경우에는 람다를, 메서드 참조가 더 간결하고 읽기 쉬운 경우에는 메서드 참조를 사용하면 된다.


### 스트림 API
**스트림(Stream)이란?**
- 자바 8부터 추가된 데이터 처리 추상화 도구로, 컬렉션/배열 등의 요소들을 일련의 단계(파이프라인)로 연결해 가공, 필터링, 집계할 수 있다.
- 내부 반복(forEach 등)을 지원해, "어떻게 반복할지"보다는 "무엇을 할지"에 집중하는 선언형 프로그래밍 스타일을 구현한다.

**중간 연산(Intermediate Operation)과 최종 연산(Terminal Operation)**
- 중간 연산: filter , map , distinct , sorted , limit 등. 스트림을 변환하거나 필터링하는 단계. 지연(Lazy) 연산이라서 실제 데이터 처리는 최종 연산을 만나기 전까지 미뤄진다.
- 최종 연산: forEach , toList , count , min , max , reduce , collect 등. 스트림 파이프라인을 종료하며 실제 연산을 수행해 결과를 반환한다. 
- 한 번 최종 연산을 수행하면 스트림은 소멸되므로, 재사용할 수 없다.

**지연 연산(Lazy Evaluation)**
- 스트림은 중간 연산 시점에 곧바로 처리하지 않고, 내부에 "어떤 연산을 할 것인지"만 저장해둔다.
- 최종 연산이 호출되는 순간에야 중간 연산들을 한 번에 적용하여 결과를 만든다.
- 덕분에 단축 평가(Short-Circuit) 같은 최적화가 가능하다. 예를 들어 findFirst() , limit() 등으로 불필요한 연산을 건너뛸 수 있다.

**파이프라인(pipeline)과 일괄 처리(batch) 비교**
- 우리가 직접 만든 MyStreamV3 처럼 모든 요소를 한 번에 처리하고, 그 결과를 모아서 다음 단계로 넘어가는 방식을 일괄 처리라고 한다.
- 자바 스트림은 요소 하나를 filter → 통과 시 바로 map → … → 최종 연산으로 넘기는 식의 파이프라인 방식으로 동작한다.
- 파이프라인 구조와 지연 연산 덕분에, 필요 이상의 연산을 줄이고 메모리 효율도 높일 수 있다.

**기본형 특화 스트림(IntStream, LongStream, DoubleStream)**
- 박싱/언박싱 오버헤드를 줄이고, 합계, 평균, 최솟값, 최댓값, 범위 생성 같은 숫자 처리에 특화된 메서드를 제공한다.
- 일반 스트림보다 루프가 매우 큰 상황에서 성능상 이점이 있을 수 있고, range() , rangeClosed() 를 통해 반복문 없이 손쉽게 범위를 다룰 수도 있다.

**Collector와 Collectors**
- collect 최종 연산을 통해 스트림 결과를 리스트나 맵, 통계 정보 등 원하는 형태로 모을 수 있다.
- Collectors 클래스는 toList, toSet, groupingBy, partitioningBy, mapping, averagingInt 같은 다양한 수집용 메서드를 제공한다.
- 특히 groupingBy 나 partitioningBy 에 다운 스트림 컬렉터를 지정하면, "그룹별 합계, 평균, 최대/최솟값, 여러 형태로 다시 매핑" 등 복합적인 요구사항을 한 번에 처리할 수 있다.